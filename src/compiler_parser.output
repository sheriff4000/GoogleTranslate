Nonterminals useless in grammar

    ASSIGN


Terminals unused in grammar

    T_FLOAT
    T_DOUBLE
    T_CHAR
    T_UINT
    T_SHORT
    T_VOID
    PLUS
    MINUS
    TIMES
    DIVIDE
    AND
    OR
    NOT
    B_AND
    B_OR
    B_NOT
    B_LSL
    B_LSR
    FLOAT_LITERAL
    STRING_LITERAL
    SLBRACKET
    SRBRACKET
    BREAK
    WHILE
    IF
    ELSE
    CASE
    DEFAULT
    VOID
    CONTINUE
    DO
    ENUM
    TYPEDEF
    VOLATILE
    STRUCT
    OP_SIZEOF


State 9 conflicts: 1 shift/reduce
State 13 conflicts: 3 shift/reduce


Grammar

    0 $accept: ROOT $end

    1 ROOT: PROG

    2 PROG: FUNC
    3     | EXPR

    4 EXPR: EXPR EXPR
    5     | LBRACKET EXPR RBRACKET
    6     | T_INT IDENT
    7     | T_INT IDENT EQUALS INT_LITERAL
    8     | IDENT EQUALS INT_LITERAL

    9 FUNC: T_INT IDENT LBRACKET RBRACKET CLBRACKET PROG RETURN_STMT CRBRACKET

   10 RETURN_STMT: RETURN INT_LITERAL
   11            | RETURN IDENT


Terminals, with rules where they appear

    $end (0) 0
    error (256)
    IDENT (258) 6 7 8 9 11
    RETURN (259) 10 11
    T_INT (260) 6 7 9
    T_FLOAT (261)
    T_DOUBLE (262)
    T_CHAR (263)
    T_UINT (264)
    T_SHORT (265)
    T_VOID (266)
    EQUALS (267) 7 8
    PLUS (268)
    MINUS (269)
    TIMES (270)
    DIVIDE (271)
    AND (272)
    OR (273)
    NOT (274)
    B_AND (275)
    B_OR (276)
    B_NOT (277)
    B_LSL (278)
    B_LSR (279)
    INT_LITERAL (280) 7 8 10
    FLOAT_LITERAL (281)
    STRING_LITERAL (282)
    LBRACKET (283) 5 9
    RBRACKET (284) 5 9
    CLBRACKET (285) 9
    CRBRACKET (286) 9
    SLBRACKET (287)
    SRBRACKET (288)
    BREAK (289)
    WHILE (290)
    IF (291)
    ELSE (292)
    CASE (293)
    DEFAULT (294)
    VOID (295)
    CONTINUE (296)
    DO (297)
    ENUM (298)
    TYPEDEF (299)
    VOLATILE (300)
    STRUCT (301)
    OP_SIZEOF (302)


Nonterminals, with rules where they appear

    $accept (48)
        on left: 0
    ROOT (49)
        on left: 1
        on right: 0
    PROG <prog> (50)
        on left: 2 3
        on right: 1 9
    EXPR <prog> (51)
        on left: 4 5 6 7 8
        on right: 3 4 5
    FUNC <prog> (52)
        on left: 9
        on right: 2
    RETURN_STMT <prog> (53)
        on left: 10 11
        on right: 9


State 0

    0 $accept: . ROOT $end

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 2
    LBRACKET  shift, and go to state 3

    ROOT  go to state 4
    PROG  go to state 5
    EXPR  go to state 6
    FUNC  go to state 7


State 1

    8 EXPR: IDENT . EQUALS INT_LITERAL

    EQUALS  shift, and go to state 8


State 2

    6 EXPR: T_INT . IDENT
    7     | T_INT . IDENT EQUALS INT_LITERAL
    9 FUNC: T_INT . IDENT LBRACKET RBRACKET CLBRACKET PROG RETURN_STMT CRBRACKET

    IDENT  shift, and go to state 9


State 3

    5 EXPR: LBRACKET . EXPR RBRACKET

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 10
    LBRACKET  shift, and go to state 3

    EXPR  go to state 11


State 4

    0 $accept: ROOT . $end

    $end  shift, and go to state 12


State 5

    1 ROOT: PROG .

    $default  reduce using rule 1 (ROOT)


State 6

    3 PROG: EXPR .
    4 EXPR: EXPR . EXPR

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 10
    LBRACKET  shift, and go to state 3

    $default  reduce using rule 3 (PROG)

    EXPR  go to state 13


State 7

    2 PROG: FUNC .

    $default  reduce using rule 2 (PROG)


State 8

    8 EXPR: IDENT EQUALS . INT_LITERAL

    INT_LITERAL  shift, and go to state 14


State 9

    6 EXPR: T_INT IDENT .
    7     | T_INT IDENT . EQUALS INT_LITERAL
    9 FUNC: T_INT IDENT . LBRACKET RBRACKET CLBRACKET PROG RETURN_STMT CRBRACKET

    EQUALS    shift, and go to state 15
    LBRACKET  shift, and go to state 16

    LBRACKET  [reduce using rule 6 (EXPR)]
    $default  reduce using rule 6 (EXPR)


State 10

    6 EXPR: T_INT . IDENT
    7     | T_INT . IDENT EQUALS INT_LITERAL

    IDENT  shift, and go to state 17


State 11

    4 EXPR: EXPR . EXPR
    5     | LBRACKET EXPR . RBRACKET

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 10
    LBRACKET  shift, and go to state 3
    RBRACKET  shift, and go to state 18

    EXPR  go to state 13


State 12

    0 $accept: ROOT $end .

    $default  accept


State 13

    4 EXPR: EXPR . EXPR
    4     | EXPR EXPR .

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 10
    LBRACKET  shift, and go to state 3

    IDENT     [reduce using rule 4 (EXPR)]
    T_INT     [reduce using rule 4 (EXPR)]
    LBRACKET  [reduce using rule 4 (EXPR)]
    $default  reduce using rule 4 (EXPR)

    EXPR  go to state 13


State 14

    8 EXPR: IDENT EQUALS INT_LITERAL .

    $default  reduce using rule 8 (EXPR)


State 15

    7 EXPR: T_INT IDENT EQUALS . INT_LITERAL

    INT_LITERAL  shift, and go to state 19


State 16

    9 FUNC: T_INT IDENT LBRACKET . RBRACKET CLBRACKET PROG RETURN_STMT CRBRACKET

    RBRACKET  shift, and go to state 20


State 17

    6 EXPR: T_INT IDENT .
    7     | T_INT IDENT . EQUALS INT_LITERAL

    EQUALS  shift, and go to state 15

    $default  reduce using rule 6 (EXPR)


State 18

    5 EXPR: LBRACKET EXPR RBRACKET .

    $default  reduce using rule 5 (EXPR)


State 19

    7 EXPR: T_INT IDENT EQUALS INT_LITERAL .

    $default  reduce using rule 7 (EXPR)


State 20

    9 FUNC: T_INT IDENT LBRACKET RBRACKET . CLBRACKET PROG RETURN_STMT CRBRACKET

    CLBRACKET  shift, and go to state 21


State 21

    9 FUNC: T_INT IDENT LBRACKET RBRACKET CLBRACKET . PROG RETURN_STMT CRBRACKET

    IDENT     shift, and go to state 1
    T_INT     shift, and go to state 2
    LBRACKET  shift, and go to state 3

    PROG  go to state 22
    EXPR  go to state 6
    FUNC  go to state 7


State 22

    9 FUNC: T_INT IDENT LBRACKET RBRACKET CLBRACKET PROG . RETURN_STMT CRBRACKET

    RETURN  shift, and go to state 23

    RETURN_STMT  go to state 24


State 23

   10 RETURN_STMT: RETURN . INT_LITERAL
   11            | RETURN . IDENT

    IDENT        shift, and go to state 25
    INT_LITERAL  shift, and go to state 26


State 24

    9 FUNC: T_INT IDENT LBRACKET RBRACKET CLBRACKET PROG RETURN_STMT . CRBRACKET

    CRBRACKET  shift, and go to state 27


State 25

   11 RETURN_STMT: RETURN IDENT .

    $default  reduce using rule 11 (RETURN_STMT)


State 26

   10 RETURN_STMT: RETURN INT_LITERAL .

    $default  reduce using rule 10 (RETURN_STMT)


State 27

    9 FUNC: T_INT IDENT LBRACKET RBRACKET CLBRACKET PROG RETURN_STMT CRBRACKET .

    $default  reduce using rule 9 (FUNC)
